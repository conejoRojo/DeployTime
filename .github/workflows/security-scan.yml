name: Security Scan (SAST + SCA + Secrets)

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]
  workflow_dispatch:

permissions:
  contents: read
  security-events: write
  pull-requests: write
  actions: read

jobs:
  # Job 1: SAST con   
  semgrep-sast:
    name: SAST - Semgrep (PHP + JavaScript)
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout codigo
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Ejecutar Semgrep SAST
        uses: semgrep/semgrep-action@v1
        with:
          config: >-
            p/owasp-top-ten
            p/php
            p/laravel
            p/javascript
            p/react
            p/sql-injection
            p/xss
            p/security-audit
          publishToken: ${{ secrets.SEMGREP_APP_TOKEN }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Subir resultados SARIF a GitHub Security
        if: always()
        uses: github/codeql-action/upload-sarif@v4
        with:
          sarif_file: semgrep.sarif
        continue-on-error: true
      
      - name: Comentar resultados en PR
        if: github.event_name == 'pull_request' && always()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            try {
              if (!fs.existsSync('semgrep.sarif')) {
                console.log('No se genero archivo SARIF');
                return;
              }
              
              const sarif = JSON.parse(fs.readFileSync('semgrep.sarif', 'utf8'));
              const results = sarif.runs[0].results || [];
              
              if (results.length > 0) {
                let comment = '## Semgrep SAST - Vulnerabilidades Detectadas\n\n';
                comment += `**Total de issues encontrados: ${results.length}**\n\n`;
                
                const critical = results.filter(r => r.level === 'error');
                const warnings = results.filter(r => r.level === 'warning');
                const notes = results.filter(r => r.level === 'note');
                
                if (critical.length > 0) {
                  comment += `### Criticos: ${critical.length}\n`;
                  critical.slice(0, 5).forEach(r => {
                    comment += `- **${r.ruleId}**: ${r.message.text}\n`;
                    comment += `  ${r.locations[0].physicalLocation.artifactLocation.uri}:${r.locations[0].physicalLocation.region.startLine}\n\n`;
                  });
                }
                
                if (warnings.length > 0) {
                  comment += `### Advertencias: ${warnings.length}\n`;
                }
                
                if (notes.length > 0) {
                  comment += `### Informativas: ${notes.length}\n`;
                }
                
                comment += '\nVer detalles completos en la pestana **Security** del repositorio.';
                
                github.rest.issues.createComment({
                  issue_number: context.issue.number,
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  body: comment
                });
              } else {
                github.rest.issues.createComment({
                  issue_number: context.issue.number,
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  body: '## Semgrep SAST - Sin Vulnerabilidades\n\nNo se detectaron vulnerabilidades de seguridad en el codigo.'
                });
              }
            } catch (error) {
              console.log('No se pudo procesar el reporte SARIF:', error);
            }

  # Job 2: SCA con Trivy
  trivy-sca:
    name: SCA - Trivy (Dependencias + Docker)
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout codigo
        uses: actions/checkout@v4

      - name: Escanear dependencias PHP (Composer)
        uses: aquasecurity/trivy-action@master
        continue-on-error: true
        with:
          scan-type: 'fs'
          scan-ref: './backend'
          format: 'sarif'
          output: 'trivy-php.sarif'
          severity: 'CRITICAL,HIGH,MEDIUM'

      - name: Subir resultados PHP a Security
        if: always()
        uses: github/codeql-action/upload-sarif@v4
        continue-on-error: true
        with:
          sarif_file: trivy-php.sarif
          category: trivy-php

      - name: Escanear dependencias Node.js (npm)
        uses: aquasecurity/trivy-action@master
        continue-on-error: true
        with:
          scan-type: 'fs'
          scan-ref: './desktop'
          format: 'sarif'
          output: 'trivy-node.sarif'
          severity: 'CRITICAL,HIGH,MEDIUM'

      - name: Subir resultados Node.js a Security
        if: always()
        uses: github/codeql-action/upload-sarif@v4
        continue-on-error: true
        with:
          sarif_file: trivy-node.sarif
          category: trivy-node

      - name: Escanear configuracion Docker
        uses: aquasecurity/trivy-action@master
        continue-on-error: true
        with:
          scan-type: 'config'
          scan-ref: '.'
          format: 'sarif'
          output: 'trivy-docker.sarif'
          severity: 'CRITICAL,HIGH,MEDIUM'

      - name: Subir resultados Docker a Security
        if: always()
        uses: github/codeql-action/upload-sarif@v4
        continue-on-error: true
        with:
          sarif_file: trivy-docker.sarif
          category: trivy-docker

  # Job 3: Deteccion de Secretos - SOLUCION GITHUB
  detect-secrets:
    name: Deteccion de Secretos Hardcodeados
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout codigo
        uses: actions/checkout@v4

      - name: Instalar dependencias
        run: |
          pip install detect-secrets
          sudo apt-get update && sudo apt-get install -y jq

      - name: Escanear secretos en el codigo
        run: |
          if [ -f ".secrets.baseline" ]; then
            echo "‚úì Usando baseline existente para detectar solo secretos nuevos"
            # Comparar scan actual con baseline. Guardar resultados para contar nuevos hallazgos.
            detect-secrets scan --baseline .secrets.baseline --all-files > .secrets.baseline.new || true
            # Reemplazar baseline con resultado merged/actualizado para que el check cuente nuevos hallazgos
            mv .secrets.baseline.new .secrets.baseline
          else
            echo "‚ö†Ô∏è Generando baseline inicial de secretos (esta ejecucion NO fallara)"
            echo "   Por favor audite y commitee .secrets.baseline"
            detect-secrets scan --all-files \
              --exclude-files '\.lock$' \
              --exclude-files 'node_modules/' \
              --exclude-files 'vendor/' \
              --exclude-files '\.git/' \
              --exclude-files 'package-lock\.json' \
              --exclude-files 'composer\.lock' \
              --exclude-files '\.min\.js$' \
              --exclude-files '\.svg$' \
              --exclude-files 'public/assets/' \
              --exclude-files 'storage/' \
              --exclude-files 'dist/' \
              --exclude-files 'build/' \
              --exclude-files '\.map$' \
              > .secrets.baseline
            # Marcar que baseline fue creado durante este run para que verify step no falle
            echo "BASELINE_CREATED=true" >> $GITHUB_ENV
            echo "::warning::Baseline inicial generada con exclusiones. Revise .secrets.baseline localmente con 'detect-secrets audit .secrets.baseline' y commitee si es correcto."
          fi

      - name: Verificar resultados
        id: check_secrets
        run: |
          SECRET_COUNT=$(jq '.results | to_entries | map(.value | length) | add // 0' .secrets.baseline)
          echo "secrets_found=$SECRET_COUNT" >> $GITHUB_OUTPUT
          
          # Si recien creamos el baseline en este run, mostrar info pero NO fallar
          if [ "${BASELINE_CREATED}" = "true" ]; then
            echo "‚úì Baseline inicial creada en este run con $SECRET_COUNT hallazgos"
            echo "  No se marcan como errores en primera ejecucion"
            echo "  Por favor audite localmente y commitee .secrets.baseline si corresponde"
            echo ""
            echo "Comandos para auditar:"
            echo "  pip install detect-secrets"
            echo "  detect-secrets audit .secrets.baseline"
            echo "  git add .secrets.baseline"
            echo "  git commit -m 'chore: baseline de secretos auditado'"
            exit 0
          fi
          
          # Si baseline ya existia, fallar solo si hay secretos (indica nuevos secretos)
          if [ "$SECRET_COUNT" -gt 0 ]; then
            echo "‚ö†Ô∏è Se encontraron $SECRET_COUNT secretos potenciales"
            echo "Esto puede indicar:"
            echo "  1. Secretos nuevos agregados al codigo"
            echo "  2. Baseline no esta auditado (use: detect-secrets audit .secrets.baseline)"
            exit 1
          else
            echo "‚úì No se encontraron secretos hardcodeados nuevos"
          fi

      - name: Comentar en PR si hay secretos nuevos
        if: failure() && github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            const secretCount = '${{ steps.check_secrets.outputs.secrets_found }}';
            const comment = `## ‚ö†Ô∏è Secretos Detectados
            
            Se encontraron **${secretCount} secretos potenciales** en el c√≥digo.
            
            **Acci√≥n requerida:**
            1. Ejecutar localmente: \`pip install detect-secrets\`
            2. Auditar baseline: \`detect-secrets audit .secrets.baseline\`
            3. Clasificar cada secreto como real o falso positivo
            4. Commitear el baseline actualizado
            
            **Si son secretos reales:**
            - Moverlos a variables de entorno (.env)
            - Rotar las credenciales si fueron expuestas
            
            Ver [documentaci√≥n de seguridad](https://github.com/${{ github.repository }}/blob/main/docs/SECURITY.md) para m√°s detalles.`;
            
            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });

  # Job 4: Resumen de Seguridad
  security-summary:
    name: Resumen de Seguridad
    runs-on: ubuntu-latest
    needs: [semgrep-sast, trivy-sca, detect-secrets]
    if: always()
    
    steps:
      - name: Generar resumen
        uses: actions/github-script@v7
        with:
          script: |
            const semgreg = '${{ needs.semgrep-sast.result }}';
            const trivy = '${{ needs.trivy-sca.result }}';
            const secrets = '${{ needs.detect-secrets.result }}';
            
            let summary = '# üîí Resumen de An√°lisis de Seguridad\n\n';
            summary += '| Herramienta | Estado | Descripci√≥n |\n';
            summary += '|-------------|--------|-------------|\n';
            
            const statusIcon = (status) => {
              if (status === 'success') return '‚úÖ';
              if (status === 'failure') return '‚ùå';
              return '‚ö†Ô∏è';
            };
            
            const statusText = (status) => {
              if (status === 'success') return 'Pas√≥';
              if (status === 'failure') return 'Fall√≥';
              return 'Omitido';
            };
            
            summary += `| ${statusIcon(semgreg)} Semgrep SAST | ${statusText(semgreg)} | An√°lisis est√°tico de c√≥digo (PHP + JS) |\n`;
            summary += `| ${statusIcon(trivy)} Trivy SCA | ${statusText(trivy)} | An√°lisis de dependencias (PHP + Node + Docker) |\n`;
            summary += `| ${statusIcon(secrets)} detect-secrets | ${statusText(secrets)} | Detecci√≥n de secretos hardcodeados |\n\n`;
            
            if (semgreg === 'success' && trivy === 'success' && secrets === 'success') {
              summary += '## ‚úÖ Todos los Checks Pasaron\n\n';
              summary += 'El c√≥digo cumple con los est√°ndares de seguridad establecidos.\n\n';
              summary += '**Pr√≥ximos pasos:**\n';
              summary += '- Revisar alertas en [Security tab](https://github.com/${{ github.repository }}/security/code-scanning)\n';
              summary += '- Priorizar vulnerabilidades CRITICAL/HIGH\n';
              summary += '- Actualizar dependencias seg√∫n sea necesario\n';
            } else {
              summary += '## ‚ö†Ô∏è Acci√≥n Requerida\n\n';
              summary += 'Se detectaron problemas de seguridad:\n\n';
              if (semgreg !== 'success') {
                summary += '- **Semgrep:** Revisar vulnerabilidades de c√≥digo en Security tab\n';
              }
              if (trivy !== 'success') {
                summary += '- **Trivy:** Revisar dependencias vulnerables en Security tab\n';
              }
              if (secrets !== 'success') {
                summary += '- **Secrets:** Auditar secretos detectados localmente\n';
                summary += '  - Comando: `detect-secrets audit .secrets.baseline`\n';
              }
              summary += '\nVer detalles en los jobs correspondientes.\n';
            }
            
            summary += '\n---\n\n';
            summary += '**üìä M√©tricas del Pipeline:**\n';
            summary += '- Costo: $0 (GitHub Actions + herramientas open source)\n';
            summary += '- Herramientas: Semgrep, Trivy, detect-secrets\n';
            summary += '- Cobertura: 100% de commits en main/develop\n';
            summary += '- Tiempo estimado: 4-6 minutos\n';
            
            await core.summary
              .addRaw(summary)
              .write();